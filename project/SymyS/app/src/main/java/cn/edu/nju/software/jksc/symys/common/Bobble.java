package cn.edu.nju.software.jksc.symys.common;

import java.util.Random;

import cn.edu.nju.software.jksc.symys.R;
import cn.edu.nju.software.jksc.symys.common.exception.CannotMixException;
import cn.edu.nju.software.jksc.symys.common.exception.CannotSwapException;

/**
 * Created by 缪晓伟 on 2015/6/16.
 */
public class Bobble implements Cloneable
{
	private int color;

	private static final Random random=new Random();

	public static final int RED_INDEX=1;
	public static final int YELLOW_INDEX=2;
	public static final int BLUE_INDEX=4;
	public static final int BLACK_INDEX=8;
	public static final int ORANGE_INDEX=3;
	public static final int PURPLE_INDEX=5;
	public static final int GREEN_INDEX=6;
	public static final int DARK_RED_INDEX=9;
	public static final int DARK_YELLOW_INDEX=10;
	public static final int DARK_BLUE_INDEX=12;
	public static final int BLANK_INDEX=0;

	private static final Bobble[] AVAILABLE_BOBBLES=new Bobble[]{new Bobble(RED_INDEX),new Bobble(YELLOW_INDEX),new Bobble(ORANGE_INDEX),
	                                                             new Bobble(BLUE_INDEX),new Bobble(PURPLE_INDEX),new Bobble(GREEN_INDEX),
	                                                             new Bobble(BLACK_INDEX),new Bobble(DARK_RED_INDEX),new Bobble(DARK_YELLOW_INDEX),
	                                                             new Bobble(DARK_BLUE_INDEX)};

	private Bobble(int color)
	{
		this.color=color;
	}

	/**
	 * This method generates a new bobble for the UI.
	 * Notice that blank bobble or blocked bobble will not be generated by this method.
	 *
	 * @return A random new bobble instance
	 */
	public static Bobble getRandomBobble()
	{
		return AVAILABLE_BOBBLES[random.nextInt(AVAILABLE_BOBBLES.length)].clone();
	}

	//Fetch 3 colors by default
	public static Bobble getRandomPrimaryBobble()
	{
		return new Bobble(1<<random.nextInt(3));
	}

	public static Bobble getRandomPrimaryBobble(int colorCount)
	{
		return new Bobble(1<<random.nextInt(colorCount));
	}


	public static Bobble getPrimaryBobbleByID(int primaryColorID)
	{
		return new Bobble(1<<(primaryColorID-1));
	}

	private String getColorName()
	{
		switch(color)
		{
			case BLANK_INDEX:
				return "Blank";
			case RED_INDEX:
				return "Red";
			case YELLOW_INDEX:
				return "Yellow";
			case ORANGE_INDEX:
				return "Orange";
			case BLUE_INDEX:
				return "Blue";
			case PURPLE_INDEX:
				return "Purple";
			case GREEN_INDEX:
				return "Green";
			case BLACK_INDEX:
				return "Black";
			case DARK_RED_INDEX:
				return "Dark red";
			case DARK_YELLOW_INDEX:
				return "Dark yellow";
			case DARK_BLUE_INDEX:
				return "Dark blue";
			default:
				return "Unknown";
		}
	}

	public int getColorID()
	{
		return color;
	}

	public int getPicID()
	{
		switch(color)
		{
			case BLANK_INDEX:
				return 0;
			case RED_INDEX:
				return R.drawable.red;
			case YELLOW_INDEX:
				return R.drawable.yellow;
			case ORANGE_INDEX:
				return R.drawable.orange;
			case BLUE_INDEX:
				return R.drawable.blue;
			case PURPLE_INDEX:
				return R.drawable.purple;
			case GREEN_INDEX:
				return R.drawable.green;
			case BLACK_INDEX:
				return R.drawable.black;
			case DARK_RED_INDEX:
				return R.drawable.dark_red;
			case DARK_YELLOW_INDEX:
				return R.drawable.dark_yellow;
			case DARK_BLUE_INDEX:
				return R.drawable.dark_blue;
			default:
				return 0;
		}
	}

	public boolean isPrimary()
	{
		return color==RED_INDEX||color==YELLOW_INDEX||color==BLUE_INDEX||color==BLACK_INDEX;
	}

	public boolean isMixed()
	{
		return isBobble()&&!isPrimary();
	}

	public boolean isBobble()
	{
		for(Bobble bobble:AVAILABLE_BOBBLES)
			if(this.equals(bobble))
				return true;
		return false;
	}

	public boolean swapWith(Bobble anotherBobble)
	{
		if(isBobble()&&anotherBobble.isBobble())
		{
			int color=this.color;
			this.color=anotherBobble.color;
			anotherBobble.color=color;
			return true;
		}
		else
			return false;
	}

	/**
	 * Notice: This method will cause some side effects to the parameter.
	 * This method implies the parameter isPointMode with default value false.
	 *
	 * @param anotherBobble Another bobble that participates in the mixing.
	 * @return true if the mix succeeds.
	 * @throws CannotMixException When any one of the bobbles cannot participate in the mixing, this exception is thrown.
	 */
	public boolean mixWith(Bobble anotherBobble)// throws CannotMixException
	{
		return mixWith(anotherBobble,false);
	}

	public boolean mixWith(Bobble anotherBobble,boolean isPointingMode)
	{
		if(isPointingMode)
		{
			if(isPrimary()&&anotherBobble.isPrimary())
			{
				this.color|=anotherBobble.color;
				anotherBobble.color=Bobble.getRandomPrimaryBobble().color;
				return true;
			}
			else
				return false;
		}
		else
		{
			if(isPrimary()&&anotherBobble.isPrimary())
			{
				this.color|=anotherBobble.color;
				anotherBobble.color=BLANK_INDEX;
				return true;
			}
			else
				return false;
		}
	}

	@Override
	public String toString()
	{
		return super.toString()+" state:"+getColorName();
	}

	@Override
	public boolean equals(Object o)
	{
		if(o==null)
			return false;
		if(o instanceof Bobble&&((Bobble)o).color==this.color)
			return true;
		else
			return false;
	}

	@Override
	public Bobble clone()
	{
		return new Bobble(this.color);
	}
}
